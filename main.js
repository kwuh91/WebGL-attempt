import * as THREE from "three";

import Stats from "three/addons/libs/stats.module.js";
import WebGL from "three/addons/capabilities/WebGL.js";

import { OrbitControls } from "three/addons/controls/OrbitControls.js";

let container, stats;

let camera, controls, scene, renderer, texture;

// let group;

let targetRotation = 0;

let windowHalfX = window.innerWidth / 2;

init();

// check for compatibility
if (WebGL.isWebGLAvailable()) {
	// Initiate function or other initializations here
	animate();
} else {
	const warning = WebGL.getWebGLErrorMessage();
	document.getElementById("container").appendChild(warning);
}

function init() {
	container = document.createElement("div");
	document.body.appendChild(container);

	scene = new THREE.Scene();
	// scene.background = new THREE.Color(0xf0f0f0);

	const axesHelper = new THREE.AxesHelper(5);
	scene.add(axesHelper);
	// The X axis is red.
	// The Y axis is green.
	// The Z axis is blue.

	camera = new THREE.PerspectiveCamera(
		50,
		window.innerWidth / window.innerHeight,
		0.1,
		100000
	);

	camera.position.set(0, 0, 5);

	scene.add(camera);

	const light = new THREE.PointLight(0xffffff, 2.5, 0, 0);
	camera.add(light);

	// group = new THREE.Group();
	// group.position.y = 50;
	// scene.add(group);

	const loader = new THREE.TextureLoader();

	function addShape(
		shape,
		extrudeSettings,
		color,
		path,
		x,
		y,
		z,
		rx,
		ry,
		rz,
		s
	) {
		// flat shape with texture
		// note: default UVs generated by THREE.ShapeGeometry are simply the x- and y-coordinates of the vertices

		// texture = loader.load(path);
		// texture.colorSpace = THREE.SRGBColorSpace;

		// // it's necessary to apply these settings in order to correctly display the texture on a shape geometry

		// texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
		// texture.repeat.set(0.2 - 0.034, 0.3 + 0.031);

		// let geometry = new THREE.ShapeGeometry(shape);

		// let mesh = new THREE.Mesh(
		// 	geometry,
		// 	new THREE.MeshPhongMaterial({
		// 		side: THREE.DoubleSide,
		// 		map: texture,
		// 	})
		// );
		// mesh.position.set(x, y, z);
		// mesh.rotation.set(rx, ry, rz);
		// mesh.scale.set(s, s, s);
		// group.add(mesh);

		// flat shape

		let geometry = new THREE.ShapeGeometry(shape);

		let mesh = new THREE.Mesh(
			geometry,
			new THREE.MeshPhongMaterial({
				color: color,
				side: THREE.DoubleSide,
			})
		);
		mesh.position.set(x, y, z);
		mesh.rotation.set(rx, ry, rz);
		mesh.scale.set(s, s, s);
		// group.add(mesh);

		// extruded shape

		// geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);

		// mesh = new THREE.Mesh(
		// 	geometry,
		// 	new THREE.MeshPhongMaterial({ color: color })
		// );
		// mesh.position.set(x, y, z - 75);
		// mesh.rotation.set(rx, ry, rz);
		// mesh.scale.set(s, s, s);
		// group.add(mesh);

		return mesh;
	}

	// Heart

	const x = 0,
		y = 0;

	const heartShape = new THREE.Shape()
		.moveTo(x + 25, y + 25)
		.bezierCurveTo(x + 25, y + 25, x + 20, y, x, y)
		.bezierCurveTo(x - 30, y, x - 30, y + 35, x - 30, y + 35)
		.bezierCurveTo(x - 30, y + 55, x - 10, y + 77, x + 25, y + 95)
		.bezierCurveTo(x + 60, y + 77, x + 80, y + 55, x + 80, y + 35)
		.bezierCurveTo(x + 80, y + 35, x + 80, y, x + 50, y)
		.bezierCurveTo(x + 35, y, x + 25, y + 25, x + 25, y + 25);

	const rect = new THREE.Shape()
		.moveTo(x, y)
		.lineTo(x + 6, y)
		.lineTo(x + 6, y + 3)
		.lineTo(x, y + 3)
		.lineTo(x, y);

	const extrudeSettings = {
		depth: 8,
		bevelEnabled: true,
		bevelSegments: 2,
		steps: 2,
		bevelSize: 1,
		bevelThickness: 1,
	};

	const wall1 = addShape(
		rect,
		extrudeSettings,
		"white",
		"path",
		0,
		0,
		0,
		0,
		-Math.PI / 2,
		0,
		1
	); //yz

	const wall2 = addShape(
		rect,
		extrudeSettings,
		"white",
		"path",
		3,
		0,
		0,
		0,
		-Math.PI / 2,
		0,
		1
	); //yz;
	const wall3 = addShape(
		rect,
		extrudeSettings,
		"white",
		"path",
		0,
		0,
		0,
		-Math.PI / 2,
		0,
		-Math.PI / 2,
		1
	); //xz;
	const wall4 = addShape(
		rect,
		extrudeSettings,
		"white",
		"path",
		0,
		3,
		0,
		-Math.PI / 2,
		0,
		-Math.PI / 2,
		1
	); //xz;

	const tunnelPiece = new THREE.Group();
	tunnelPiece.add(wall1);
	tunnelPiece.add(wall2);
	tunnelPiece.add(wall3);
	tunnelPiece.add(wall4);

	// scene.add(tunnelPiece);

	const tunnelPiece2 = tunnelPiece.clone();
	tunnelPiece2.position.z += 6;
	tunnelPiece2.rotation.x += Math.PI / 2;

	// scene.add(tunnelPiece2);

	const tunnelPiece3 = tunnelPiece.clone();
	tunnelPiece3.position.z += 6;
	tunnelPiece3.position.y += 3;
	tunnelPiece3.position.x += 3;
	tunnelPiece3.rotation.x += Math.PI / 2;
	tunnelPiece3.rotation.y += Math.PI;

	// scene.add(tunnelPiece3);

	const tunnelPiece4 = tunnelPiece.clone();
	tunnelPiece4.position.z += 6 + 3;

	// scene.add(tunnelPiece4);

	const tunnelPiece5 = tunnelPiece.clone();
	tunnelPiece5.position.z += 6;
	tunnelPiece5.position.x += 3;
	tunnelPiece5.rotation.x += Math.PI / 2;
	tunnelPiece5.rotation.y += Math.PI / 2;

	// scene.add(tunnelPiece5);

	const tunnelPiece6 = tunnelPiece.clone();
	tunnelPiece6.position.z += 6;
	tunnelPiece6.position.x -= 6;
	tunnelPiece6.rotation.x += Math.PI / 2;
	tunnelPiece6.rotation.y += Math.PI / 2;

	// scene.add(tunnelPiece6);

	const cross = new THREE.Group();
	cross.add(tunnelPiece);
	cross.add(tunnelPiece2);
	cross.add(tunnelPiece3);
	cross.add(tunnelPiece4);
	cross.add(tunnelPiece5);
	cross.add(tunnelPiece6);

	scene.add(cross);

	const cross2 = cross.clone();
	cross2.position.z += 6 + 3 + 6;
	scene.add(cross2);

	// addShape( shape, extrudeSettings, color, x, y, z, rx, ry,rz, s );

	// addShape(
	// 	heartShape,
	// 	extrudeSettings,
	// 	0xf00000,
	// 	60,
	// 	100,
	// 	0,
	// 	0,
	// 	0,
	// 	Math.PI,
	// 	1
	// );

	// // // // // // // // // // //

	renderer = new THREE.WebGLRenderer({ antialias: true });
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth, window.innerHeight);
	container.appendChild(renderer.domElement);

	controls = new OrbitControls(camera, renderer.domElement);
	controls.update();

	stats = new Stats();
	container.appendChild(stats.dom);

	container.style.touchAction = "none";

	window.addEventListener("resize", onWindowResize);
}

function onWindowResize() {
	windowHalfX = window.innerWidth / 2;

	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();

	renderer.setSize(window.innerWidth, window.innerHeight);
}

camera.position.x += 1.5;
camera.position.y += 1.5;
camera.position.z -= 10.5;

camera.rotation.y += Math.PI;

function animate() {
	requestAnimationFrame(animate);

	// tunnelPiece2.rotation.z += 0.01;

	// texture.repeat.x += 0.0005;
	// group.children[1].rotation.x += 0.01;

	// group.children[1].rotation.y += 0.01;

	// group.children[1].rotation.z += 0.01;

	camera.position.z += 0.05;
	// camera.position.z -= 0.1;

	render();
	stats.update();
}

function render() {
	// group.rotation.y += (targetRotation - group.rotation.y) * 0.05;
	renderer.render(scene, camera);
}
